#!/usr/bin/env python
import os
import pprint
import json
import re
import datetime
import re


fileName = 'flash-matrix.json'
dt_date = datetime.datetime.now()

featureMatrix = {
    'modifiedOn': dt_date.strftime("%A, %d %b %Y"),
    'matrix':
    {
        'accessibility' : { # Checked
            'Accessibility':dict(),
            'AccessibilityImplementation':dict(),
            'AccessibilityProperties': dict(),
            'ISearchableText': dict(),
            'ISimpleTextSelection': dict()
        },
        #'automation' : { # Checked
        #    'ActionGenerator': dict(),
        #    'AutomationAction':dict(),
        #    'Configuration':dict(),
        #    'KeyboardAutomationAction':dict(),
        #    'MouseAutomationAction':dict(),
        #    'StageCapture':dict(),
        #    'StageCaptureEvent':dict()
        #},
        'desktop' : { # Checked
            'Clipboard':dict(),
            'ClipboardFormats':dict(),
            'ClipboardTransferMode':dict(),
            #'IFilePromise':dict()  AIR
         	#Icon AIR
         	#InteractiveIcon AIR
         	#InvokeEventReason AIR
         	#NativeApplication AIR
         	#NativeDragActions AIR
         	#NativeDragManager AIR
         	#NativeDragOptions AIR
         	#NativeProcess AIR
         	#NativeProcessStartupInfo AIR
         	#NotificationType AIR
         	#SystemIdleMode AIR
         	#SystemTrayIcon AIR
         	#Updater AIR
        },
        'display' : { # Checked
            'AVM1Movie': dict(),
            'ActionScriptVersion': dict(),
            'AVM1Movie': dict(),
            'Bitmap': dict(),
            'BitmapData': dict(),
            'BitmapDataChannel': dict(),
            'BitmapEncodingColorSpace': dict(),
            'BlendMode': dict(),
            'CapsStyle': dict(),
            'ColorCorrection': dict(),
            'ColorCorrectionSupport': dict(),
            'DisplayObject': dict(),
            'DisplayObjectContainer': dict(),
            #'FocusDirection': dict(), Is AIR
            'FrameLabel': dict(),
            'GradientType': dict(),
            'Graphics': dict(),
            'GraphicsBitmapFill': dict(),
            'GraphicsEndFill': dict(),
            'GraphicsGradientFill': dict(),
            'GraphicsPath': dict(),
            'GraphicsPathCommand': dict(),
            'GraphicsPathWinding': dict(),
            'GraphicsShaderFill': dict(),
            'GraphicsSolidFill': dict(),
            'GraphicsStroke': dict(),
            'GraphicsTrianglePath': dict(),
            'IBitmapDrawable': dict(),
            'IGraphicsData': dict(),
            'IGraphicsFill': dict(),
            'IGraphicsPath': dict(),
            'IGraphicsStroke': dict(),
            'InteractiveObject': dict(),
            'InterpolationMethod': dict(),
            'JointStyle': dict(),
            'JPEGEncoderOptions': dict(),
            'JPEGXREncoderOptions': dict(),
            'LineScaleMode': dict(),
            'Loader': dict(),
            'LoaderInfo': dict(),
            'MorphShape': dict(),
            'MovieClip': dict(),
            #'NativeMenu': dict(),
         	#'NativeMenuItem': dict(),
         	#'NativeWindow': dict(),
         	#'NativeWindowDisplayState': dict(),
         	#'NativeWindowInitOptions': dict(),
         	#'NativeWindowRenderMode': dict(),
         	#'NativeWindowResize': dict(),
         	#'NativeWindowSystemChrome': dict(),
         	#'NativeWindowType': dict(),
            'PixelSnapping': dict(),
            'PNGEncoderOptions': dict(),
            'Scene': dict(),
            #Screen
            #ScreenMode
            'Shader': dict(),
            'ShaderData': dict(),
            'ShaderInput': dict(),
            'ShaderJob': dict(),
            'ShaderParameter': dict(),
            'ShaderParameterType': dict(),
            'ShaderPrecision': dict(),
            'Shape': dict(),
            'SimpleButton': dict(),
            'SpreadMethod': dict(),
            'Sprite': dict(),
            'Stage': dict(),
            'Stage3D': dict(),
            'StageAlign': dict(),
            #	StageAspectRatio
            'StageDisplayState': dict(),
            #StageOrientation
            'StageQuality': dict(),
            'StageScaleMode': dict(),
            'SWFVersion': dict(),
            'TriangleCulling': dict()
        },
        'display3D' : { # Checked
            'Context3D': dict(),
            'Context3DBlendFactor': dict(),
            'Context3DBufferUsage': dict(),
            'Context3DClearMask': dict(),
            'Context3DCompareMode': dict(),
            #Context3DFillMode   AIR
            'Context3DMipFilter': dict(),
            'Context3DProfile': dict(),
            'Context3DProgramType': dict(),
            'Context3DRenderMode': dict(),
            'Context3DStencilAction': dict(),
            'Context3DTextureFilter': dict(),
            'Context3DTextureFormat': dict(),
            'Context3DTriangleFace': dict(),
            'Context3DVertexBufferFormat': dict(),
            'Context3DWrapMode': dict(),
            'IndexBuffer3D': dict(),
            'Program3D': dict(),
            'VertexBuffer3D': dict(),
        },
        'errors' : {
            #'DRMManagerError': dict(), AIR
            'EOFError': dict(),
            'IllegalOperationError': dict(),
            'InvalidSWFError': dict(),
            'IOError': dict(),
            'MemoryError': dict(),
            # 'PermissionError': dict(), AIR
            'ScriptTimeoutError': dict(),
            #'SQLError': dict(), AIR
            #'SQLErrorOperation': dict(), AIR
            'StackOverflowError': dict()
        },
        'events' : {
            'AccelerometerEvent': dict(),
            'ActivityEvent': dict(),
            'AsyncErrorEvent': dict(),
            # BrowserInvokeEvent AIR
            'ContextMenuEvent': dict(),
            'DataEvent': dict(),
            'ErrorEvent': dict(),
            'Event': dict(),
            'EventDispatcher': dict(),
            'EventPhase': dict(),
            'FocusEvent': dict(),
            'FullScreenEvent': dict(),
            #'GameInputEvent': dict(), AIR
            #'GeolocationEvent': dict(), AIR/FlashLite
            'GestureEvent': dict(),
            'GesturePhase': dict(),
            'HTTPStatusEvent': dict(),
            'IEventDispatcher': dict(),
            'IMEEvent': dict(),
            'IOErrorEvent': dict(),
            'KeyboardEvent': dict(),
            'MouseEvent': dict(),
            'NetDataEvent': dict(),
            'NetMonitorEvent': dict(),
            'NetStatusEvent': dict(),
            #'OutputProgressEvent': dict(), AIR
            'PressAndTapGestureEvent': dict(),
            'ProgressEvent': dict(),
            'SampleDataEvent': dict(),
            'SecurityErrorEvent': dict(),
            'ShaderEvent': dict(),
            'SoftKeyboardEvent': dict(),
            'SoftKeyboardTrigger': dict(),
            'StageVideoAvailabilityEvent': dict(),
            'StageVideoEvent': dict(),
            'StatusEvent': dict(),
            'SyncEvent': dict(),
            'TextEvent': dict(),
            'ThrottleEvent': dict(),
            'ThrottleType': dict(),
            'TimerEvent': dict(),
            'TouchEvent': dict(),
            'TransformGestureEvent': dict(),
            'UncaughtErrorEvent': dict(),
            'UncaughtErrorEvents': dict(),
            'VideoEvent': dict()
        },
        'external' : { # Checked
            # 'ExtensionContext' AIR
            'ExternalInterface':dict()
        },
        'filters' : { # Checked
            'BevelFilter': dict(),
            'BevelFilter': dict(),
            'BitmapFilter': dict(),
            'BitmapFilterQuality': dict(),
            'BitmapFilterType': dict(),
            'BlurFilter': dict(),
            'ColorMatrixFilter': dict(),
            'ConvolutionFilter': dict(),
            'DisplacementMapFilter': dict(),
            'DisplacementMapFilterMode': dict(),
            'DropShadowFilter': dict(),
            'GlowFilter': dict(),
            'GradientBevelFilter': dict(),
            'GradientGlowFilter': dict(),
            'ShaderFilter': dict()
        },
        'geom' : { # Checked
            'ColorTransform': dict(),
            'Matrix': dict(),
            'Matrix3D': dict(),
            'Orientation3D': dict(),
            'PerspectiveProjection': dict(),
            'Point': dict(),
            'Rectangle': dict(),
            'Transform': dict(),
            'Utils3D': dict(),
            'Vector3D': dict()
        },
        'globalization' : { # Checked
            'Collator': dict(),
            'CollatorMode': dict(),
            'CurrencyFormatter': dict(),
            'CurrencyParseResult': dict(),
            'DateTimeFormatter': dict(),
            'DateTimeNameContext': dict(),
            'DateTimeNameStyle': dict(),
            'DateTimeStyle': dict(),
            'LastOperationStatus': dict(),
            'LocaleID': dict(),
            'NationalDigitsType': dict(),
            'NumberFormatter': dict(),
            'NumberParseResult': dict(),
            'StringTools': dict()
        },
        'media' : { # Checked
            'AudioDecoder': dict(),
            'AudioDeviceManager': dict(),
            'AudioOutputChangeReason': dict(),
            #AudioPlaybackMode AIR
            'AVNetworkingParams': dict(),
            'AVTagData': dict(),
            'AVURLLoader': dict(),
            'AVURLStream': dict(),
            'Camera': dict(),
            #CameraPositionAIR
            #CameraRollAIR
            #CameraRollBrowseOptionsAIR
            #CameraUIAIR
            'H264Level': dict(),
            'H264Profile': dict(),
            'H264VideoStreamSettings': dict(),
            'ID3Info': dict(),
            #MediaPromise AIR
            #MediaType AIR
            'Microphone': dict(),
            'MicrophoneEnhancedMode': dict(),
            'MicrophoneEnhancedOptions': dict(),
            'Sound': dict(),
            'SoundChannel': dict(),
            'SoundCodec': dict(),
            'SoundLoaderContext': dict(),
            'SoundMixer': dict(),
            'SoundTransform': dict(),
            'StageVideo': dict(),
            'StageVideoAvailability': dict(),
            'StageVideoAvailabilityReason': dict(),
            #StageWebView AIR
            'Video': dict(),
            'VideoCodec': dict(),
            'VideoStatus': dict(),
            'VideoStreamSettings': dict()
        },
        'net' : { # Checked
            #'DatagramSocket': dict(), AIR
            'FileFilter': dict(),
            'FileReference': dict(),
            'FileReferenceList': dict(),
            'GroupSpecifier': dict(),
            #'InterfaceAddress': dict(), AIR
            #'IPVersion': dict(), AIR
            'LocalConnection': dict(),
            'NetConnection': dict(),
            'NetGroup': dict(),
            'NetGroupInfo': dict(),
            'NetGroupReceiveMode': dict(),
            'NetGroupReplicationStrategy': dict(),
            'NetGroupSendMode': dict(),
            'NetGroupSendResult': dict(),
            'NetMonitor': dict(),
            'NetStream': dict(),
            'NetStreamAppendBytesAction': dict(),
            'NetStreamInfo': dict(),
            'NetStreamMulticastInfo': dict(),
            'NetStreamPlayOptions': dict(),
            'NetStreamPlayTransitions': dict(),
            #'NetworkInfo': dict(), AIR
            #'NetworkInterface': dict(), AIR
            'ObjectEncoding': dict(),
            'Responder': dict(),
            'SecureSocket': dict(),
            #'ServerSocket': dict(), AIR
            'SharedObject': dict(),
            'SharedObjectFlushStatus': dict(),
            'Socket': dict(),
            'URLLoader': dict(),
            'URLLoaderDataFormat': dict(),
            'URLRequest': dict(),
            'URLRequestDefaults': dict(),
            'URLRequestHeader': dict(),
            'URLRequestMethod': dict(),
            'URLStream': dict(),
            'URLVariables': dict(),
            'XMLSocket': dict()
        },
        'printing' : { # Checked
            #'PaperSize': dict(), AIR
            'PrintJob': dict(),
            'PrintJobOptions': dict(),
            'PrintJobOrientation': dict(),
            # 'PrintMethod': dict(), AIR
            #'PrintUIOptions': dict(), AIR
        },
        'profiler' : { # Checked
            'Telemetry': dict()
        },
        'sampler' : { # Checked
            'DeleteObjectSample': dict(),
            'NewObjectSample': dict(),
            'Sample': dict(),
            'StackFrame': dict()
        },
        'security' : { # Checked
            'CertificateStatus': dict(),
            #'ReferencesValidationSetting': dict(),
            #'RevocationCheckSettings': dict(),
            #'SignatureStatus': dict(),
            #'SignerTrustSettings': dict(),
            #'X500DistinguishedName': dict(),
            'X509Certificate': dict(),
            #'XMLSignatureValidator': dict(),
        },
        'sensors' : { # Checked
            'Accelerometer': dict(),
            #'DeviceRotation': dist(), AIR
            #'Geolocation': dict(), AIR
        },
        'system' : { # Checked
            'ApplicationDomain': dict(),
            'Capabilities': dict(),
            #'ImageDecodingPolicy': dict(), AIR
            'IME': dict(),
            'IMEConversionMode': dict(),
            'JPEGLoaderContext': dict(),
            'LoaderContext': dict(),
            'MessageChannel': dict(),
            'MessageChannelState': dict(),
            'Security': dict(),
            'SecurityDomain': dict(),
            'SecurityPanel': dict(),
            'System': dict(),
            'SystemUpdater': dict(),
            'SystemUpdaterType': dict(),
            'TouchscreenType': dict(),
            'Worker': dict(),
            'WorkerDomain': dict(),
            'WorkerState': dict(),
        },
        'text' : { # Checked
            'AntiAliasType': dict(),
            #'AutoCapitalize' AIR
            'CSMSettings': dict(),
            'Font': dict(),
            'FontStyle': dict(),
            'FontType': dict(),
            'GridFitType': dict(),
            #ReturnKeyLabel AIR
        	#SoftKeyboardType AIR
        	#StageText AIR
         	#StageTextClearButtonMode AIR
         	#StageTextInitOptions AIR
            'StaticText': dict(),
            'StyleSheet': dict(),
            'TextColorType': dict(),
            'TextDisplayMode': dict(),
            'TextField': dict(),
            'TextFieldAutoSize': dict(),
            'TextFieldType': dict(),
            'TextFormat': dict(),
            'TextFormatAlign': dict(),
            #'TextFormatDisplay': dict(),
            'TextInteractionMode': dict(),
            'TextLineMetrics': dict(),
            'TextRenderer': dict(),
            'TextSnapshot': dict(),
        },
        'trace' : {
            'Trace': dict()
        },
        'ui' : { # Checked
            'ContextMenu': dict(),
            'ContextMenuBuiltInItems': dict(),
            'ContextMenuClipboardItems': dict(),
            'ContextMenuItem': dict(),
            #'GameInput': dict(), AIR
            #'GameInputControl': dict(), AIR
            #'GameInputDevice': dict(), AIR
            #'GameInputFinger': dict(),
            #'GameInputHand': dict(),
            'KeyLocation': dict(),
            'Keyboard': dict(),
            'KeyboardType': dict(),
            'Mouse': dict(),
            'MouseCursor': dict(),
            'MouseCursorData': dict(),
            'Multitouch': dict(),
            'MultitouchInputMode': dict()
        },
        'utils' : { # Checked
            'CompressionAlgorithm': dict(),
            'Endian': dict(),
            'IDataInput': dict(),
            'IDataOutput': dict(),
            'Timer': dict(),
            'ByteArray': dict(),
            'Dictionary': dict()
        }
    }
}

matrix = featureMatrix['matrix']

# Add Flash Players to matrix
for category in matrix:
    for feature in matrix[category]:
        matrix[category][feature] = {'adobeflash' : 'Yes', 'shumway' : 'No', 'lightspark': 'No', 'gnash': 'No', 'ruffle': 'No', 'awayfl': 'No'}

#==================Parse Flash Players for stats==================

# Parse AwayFL Files

dir = './playerglobal/lib'
for subdir, dirs, files in os.walk(dir):
    for file in files:
        if file.endswith('.ts'):
            fileContent = open(os.path.join(subdir, file), "r")
            lines = fileContent.read()
            subDirKey = subdir.replace(dir + '/','')
            fileKey = file.replace('.ts', '')
            if subDirKey in matrix.keys():
                if fileKey in matrix[subDirKey].keys():
                    #if  lines.find('// @todo"'):
                    #    matrix[subDirKey][fileKey]['awayfl'] = 'Partially'
                    if lines.find('not implemented') > 0:
                        matrix[subDirKey][fileKey]['awayfl'] = 'Partially' # No
                    else:
                        matrix[subDirKey][fileKey]['awayfl'] = 'Yes'

#  Parse Shumway files
dir = './shumway/src/flash'
for subdir, dirs, files in os.walk(dir):
    for file in files:
        if file.endswith('.ts'):
            fileContent = open(os.path.join(subdir, file), "r")
            lines = fileContent.read()
            subDirKey = subdir.replace(dir + '/','')
            fileKey = file.replace('.ts', '')
            if subDirKey in matrix.keys():
                if fileKey in matrix[subDirKey].keys():
                    if lines.find('somewhatImplemented(') > 0:
                        matrix[subDirKey][fileKey]['shumway'] = 'Partially'
                    elif lines.find('notImplemented(') > 0:
                        matrix[subDirKey][fileKey]['shumway'] = 'Partially' # No
                    else:
                        matrix[subDirKey][fileKey]['shumway'] = 'Yes'

# Use https://github.com/mozilla/shumway/blob/16451d8836fa85f4b16eeda8b4bda2fa9e2b22b0/utils/playerglobal-builder/manifest.json
# for better understanding of what is supported.

# Parse Gnash files

dir = './gnash/libcore/'

for subdir, dirs, files in os.walk(dir):
    for file in files:
        if file.endswith('.cpp'):
            fileKey = file.replace('.cpp', '')
            for item in matrix:
                if fileKey in matrix[item].keys():
                    matrix[item][fileKey]['gnash'] = 'Partially'

for subdir, dirs, files in os.walk(dir):
    for file in files:
        if file.endswith('_as.cpp'):
            fileContent = open(os.path.join(subdir, file), "r")
            lines = fileContent.read()
            subDirKey = subdir.replace(dir + '/','')
            fileKey = file.replace('_as.cpp', '')
            for item in matrix:
                if fileKey in matrix[item].keys():
                    matrix[item][fileKey]['gnash'] = 'Yes'

for subdir, dirs, files in os.walk(dir):
    for file in files:
        if file.endswith('.cpp'):
            fileContent = open(os.path.join(subdir, file), "r")
            lines = fileContent.read()
            m = re.findall('\w+\(vm, "(\w+)"\)', lines)     # Be more specific
            for item in matrix:
                for found in m:
                    if fileKey in matrix[item].keys():
                        matrix[item][fileKey]['gnash'] = 'Yes'

# Parse Lightspark files
# Find Lightspark features
lightsparkRegisters = [
"./lightspark/src/scripting/abc_avm1.cpp",
"./lightspark/src/scripting/abc_flashaccessibility.cpp",
"./lightspark/src/scripting/abc_flashdesktop.cpp",
"./lightspark/src/scripting/abc_flashconcurrent.cpp",
"./lightspark/src/scripting/abc_flashcrypto.cpp",
"./lightspark/src/scripting/abc_flashdisplay.cpp",
"./lightspark/src/scripting/abc_flashdisplay3d.cpp",
"./lightspark/src/scripting/abc_flashevents.cpp",
"./lightspark/src/scripting/abc_flasherrors.cpp",
"./lightspark/src/scripting/abc_flashexternal.cpp",
"./lightspark/src/scripting/abc_flashfilesystem.cpp",
"./lightspark/src/scripting/abc_flashfilters.cpp",
"./lightspark/src/scripting/abc_flashgeom.cpp",
"./lightspark/src/scripting/abc_flashglobalization.cpp",
"./lightspark/src/scripting/abc_flashmedia.cpp",
"./lightspark/src/scripting/abc_flashnet.cpp",
"./lightspark/src/scripting/abc_flashprinting.cpp",
"./lightspark/src/scripting/abc_flashsampler.cpp",
"./lightspark/src/scripting/abc_flashsecurity.cpp",
"./lightspark/src/scripting/abc_flashsensors.cpp",
"./lightspark/src/scripting/abc_flashsystem.cpp",
"./lightspark/src/scripting/abc_flashtext.cpp",
"./lightspark/src/scripting/abc_flashui.cpp",
"./lightspark/src/scripting/abc_flashutils.cpp",
"./lightspark/src/scripting/abc_flashxml.cpp",
"./lightspark/src/scripting/abc_avmplus.cpp",
"./lightspark/src/scripting/abc_toplevel.cpp",
]

for file in lightsparkRegisters:
    fileContent = open(file, "r")
    lines = fileContent.read()
    m = re.findall('builtin\-\>registerBuiltin\("(\w+)",', lines)
    for item in matrix:
        for found in m:
            if found in matrix[item].keys():
                matrix[item][found]['lightspark'] = 'Yes'

# Find more lightspark features - This needs to be improved
fileContent = open('./lightspark/src/allclasses.h', "r")
lines = fileContent.read()
m = re.findall('REGISTER_CLASS_NAME\((\w+),\"(.*)\"', lines)
# Fill in matrix here TODO

m = re.findall('REGISTER_CLASS_NAME2\((\w+),\"(.*)\"', lines)
# Fill in matrix here TODO

# Find "Not implemented in all features to set as partially complete"
dir = './lightspark/src/scripting/'
for subdir, dirs, files in os.walk(dir):
    for file in files:
        if file.endswith('.cpp'):
            fileContent = open(os.path.join(subdir, file), "r")
            lines = fileContent.read()
            m = re.findall('LOG\(LOG_NOT_IMPLEMENTED,\"(\w+) is not implemented', lines)
            for item in matrix:
                for found in m:
                    if found in matrix[item].keys():
                        matrix[item][found]['lightspark'] = 'Partially' # No

# Find "Not implemented in all features to set as partially complete"
for subdir, dirs, files in os.walk(dir):
    for file in files:
        if file.endswith('.cpp'):
            fileContent = open(os.path.join(subdir, file), "r")
            lines = fileContent.read()
            m = re.findall('LOG\(LOG_NOT_IMPLEMENTED,\"(\w+)\.', lines)
            for item in matrix:
                for found in m:
                    if found in matrix[item].keys():
                        matrix[item][found]['lightspark'] = 'Partially'

# Parse Ruffle files

dir = './ruffle/core/src/avm2/globals/flash/'

def ruffleFileKey(fileName):
    fileKey = fileName.replace('.rs', '')
    fileKey = fileKey.replace('.as', '')
    fileKey = fileKey.lower()
    fileKey = re.sub(r'[^a-zA-Z0-9]', '', fileKey)
    return fileKey

# We assume here that if the file exists then it is implemented 100%
for subdir, dirs, files in os.walk(dir):
    for file in files:
        if file.endswith('.rs') or file.endswith('.as'):
            fileKey = ruffleFileKey(file)
            for item in matrix:
                for key, value in matrix[item].items():
                    if fileKey.lower() == key.lower():
                        matrix[item][key]['ruffle'] = 'Yes'

# Find "Not implemented in all features to set as partially complete"
for subdir, dirs, files in os.walk(dir):
    for file in files:
        if file.endswith('.rs') or file.endswith('.as'):
            fileContent = open(os.path.join(subdir, file), "r")
            lines = fileContent.read()
            m = re.findall('log(?:\:\:|_)warn\!?\(\"(.*)\..* (?:[n|N]ot.* implemented|is a stub)\"\)', lines)
            for item in matrix:
                for found in m:
                    if found in matrix[item].keys():
                        matrix[item][found]['ruffle'] = 'Partially'

# Override some features
matrix['trace']['Trace']['lightspark'] = 'Yes'
matrix['display']['Shader']['lightspark'] = 'No'
matrix['display']['Shader']['shumway'] = 'No'
matrix['display']['ShaderInput']['shumway'] = 'No'
matrix['display']['ShaderJob']['shumway'] = 'No'
matrix['display']['ShaderParameter']['shumway'] = 'No'
matrix['display']['ShaderPrecision']['shumway'] = 'No'
matrix['trace']['Trace']['ruffle'] = 'Yes'

with open(fileName, "r") as read_file:
    existingFeatureMatrix = json.load(read_file)

if (sorted(existingFeatureMatrix['matrix'].items()) != sorted(featureMatrix['matrix'].items())):
    print("File is differnet.")

with open(fileName, "w") as write_file:
    json.dump(featureMatrix, write_file ,indent = 2)
